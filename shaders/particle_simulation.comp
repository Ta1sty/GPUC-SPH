#version 450

layout(local_size_x_id = 0, local_size_y = 1, local_size_z = 1) in;

layout(binding = 0) buffer positionBuffer { float positions[]; };
layout(binding = 1) buffer velocityBuffer { float velocities[]; };

layout(push_constant) uniform PushStruct {
    float gravity;
    float deltaTime;
    uint numParticles;
    float collisionDampingFactor;
    float spatialRadius;
}
constants;

#define GRID_BUFFER_SIZE constants.numParticles
#define GRID_CELL_SIZE constants.spatialRadius
#define GRID_BINDING_LOOKUP 2
#define GRID_BINDING_INDEX 3
#include "spatial_lookup.glsl"

const float PI = 3.14159265359;

float smoothingKernel(float radius, float dist) {
    float volume = PI* pow(radius, 8) / 4;
    float value = max(0, radius*radius - dist*dist);
    return value * value * value / volume;
}

float smoothingKernelDerivative(float radius, float dist) {
    if (dist >= radius) return 0.0;
    float f = radius*radius - dist*dist;
    float scale = -24.0 / (PI * pow(radius, 8));
    return scale * dist * f * f;
}

float evaluateDensity(vec2 pos, float radius) {
    uint cellKey = cellKey(pos);
    const float mass = 1.0;
    
    float density = 0.0;

    uint spatialLookupIndex = spatial_indices[cellKey];
    SpatialLookupEntry currentEntry = spatial_lookup[spatialLookupIndex];
    while (currentEntry.cellKey == cellKey) {
        uint currentParticleIndex = currentEntry.particleIndex;
        vec2 currentPosition = vec2(positions[2 * currentParticleIndex], positions[2 * currentParticleIndex + 1]);
        float dist = length(currentPosition - pos);
        float influence = smoothingKernel(radius, dist);
        density += mass * influence;
        currentEntry = spatial_lookup[++spatialLookupIndex];
    }
    return density;
}

float evaluateDensityGradient(vec2 pos, float radius) {
    uint cellKey = cellKey(pos);
    const float mass = 1.0;
    
    vec2 gradient = vec2(0.0, 0.0);

    uint spatialLookupIndex = spatial_indices[cellKey];
    SpatialLookupEntry currentEntry = spatial_lookup[spatialLookupIndex];
    while (currentEntry.cellKey == cellKey) {
        uint currentParticleIndex = currentEntry.particleIndex;
        vec2 currentPosition = vec2(positions[2 * currentParticleIndex], positions[2 * currentParticleIndex + 1]);
        vec2 diff = currentPosition - pos;
        float dist = length(diff);
        vec2 direction = diff / dist;
        vec2 slope = smoothingKernelDerivative(radius, dist)
        float density = evaluateDensity(currentPosition, radius);
        gradient += mass * influence;
        currentEntry = spatial_lookup[++spatialLookupIndex];
    }
    return length(gradient);
}

void main() {
    uint index = gl_GlobalInvocationID.x;
    if (index >= constants.numParticles) return;

    vec2 position = vec2(positions[2 * index], positions[2 * index + 1]);
    vec2 velocity = vec2(velocities[2 * index], velocities[2 * index + 1]);
    float density = evaluateDensity(position, constants.spatialRadius);

    // Update velocity
    velocity += vec2(0.0, constants.gravity) * constants.deltaTime;
    // Update position
    position += velocity * constants.deltaTime;


    // Resolve collisions
    if (position.x < 0.0) {
        position.x = -position.x;
        velocity *= -constants.collisionDampingFactor;
    } else if (position.x > 1.0) {
        position.x = 2 - position.x;
        velocity *= -constants.collisionDampingFactor;
    }
    if (position.y < 0.0) {
        position.y = -position.y;
        velocity *= -constants.collisionDampingFactor;
    } else if (position.y > 1.0) {
        position.y = 2 - position.y;
        velocity *= -constants.collisionDampingFactor;
    }


    positions[2 * index] = position.x;
    positions[2 * index + 1] = position.y;
    velocities[2 * index] = velocity.x;
    velocities[2 * index + 1] = velocity.y;

}